<!DOCTYPE html>
<html lang="es">
<head>
  <script src="enemy-generic.js"></script>
  <script src="enemy-flying.js"></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chroméphage - Prototipo Canvas</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: white;
      font-family: 'Segoe UI', sans-serif;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.4);
      padding: 10px 15px;
      border-radius: 10px;
      z-index: 10;
    }
    #waveInfo {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.4);
      padding: 10px 15px;
      border-radius: 10px;
      z-index: 10;
    }
    #toleranceInfo {
      position: absolute;
      top: 60px;
      left: 10px;
      background: rgba(0,0,0,0.4);
      padding: 10px 15px;
      border-radius: 10px;
      z-index: 10;
      font-size: 14px;
    }
    #mapInfo {
      position: absolute;
      top: 110px;
      left: 10px;
      background: rgba(0,0,0,0.4);
      padding: 10px 15px;
      border-radius: 10px;
      z-index: 10;
      font-size: 14px;
    }
    #debugInfo {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(255,0,0,0.4);
      padding: 10px 15px;
      border-radius: 10px;
      z-index: 10;
      font-size: 12px;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: rgba(255,255,255,0.05);
      border: 2px solid #444;
    }
  </style>
</head>
<body>
  <div id="hud">Modo: RGB | Color: Ninguno | Opacidad: 10%</div>
  <div id="waveInfo">Oleada: 1 | Enemigos: 3</div>
  <div id="toleranceInfo">Tolerancia: Media (▲/▼ para ajustar)</div>
  <div id="mapInfo">Mapa: Cargando...</div>
  <div id="debugInfo">Debug: -</div>
  <canvas id="game" width="800" height="600"></canvas>
 <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hud = document.getElementById('hud');
    const waveInfo = document.getElementById('waveInfo');
    const toleranceInfo = document.getElementById('toleranceInfo');
    const mapInfo = document.getElementById('mapInfo');
    const debugInfo = document.getElementById('debugInfo');

    const player = { x: 400, y: 500, size: 20, speed: 4, color: 'white' };
    const enemies = [];
    const fallenBlocks = [];
    
    // Proyectiles
    const projectiles = [];

    let zoomLevel = 1.5;

    // SISTEMA DE PALETAS DINÁMICAS
    let colorMode = 'RGB'; // 'RGB' o 'MYC'
    
    const palettes = {
      'RGB': {
        '1': {r:255, g:0, b:0, name:"Rojo"},
        '2': {r:0, g:255, b:0, name:"Verde"},
        '3': {r:0, g:0, b:255, name:"Azul"}
      },
      'MYC': {
        '1': {r:255, g:0, b:255, name:"Magenta"},
        '2': {r:255, g:255, b:0, name:"Amarillo"},
        '3': {r:0, g:255, b:255, name:"Cian"}
      }
    };

    // Función para obtener colores activos
    function getActiveColors() {
      return palettes[colorMode];
    }

    const predefinedMaps = [
      {
        name: "Mapa Test 1",
        type: "image",
        url: "https://i.ibb.co/93GBxC9z/mapa.png?1"
      }
    ];

    let selectedColor = null;
    let opacity = 0.1;
    
    const toleranceLevels = [
      { name: "Media", value: 35 },
      { name: "Alta", value: 50 },
      { name: "Muy Alta", value: 70 }
    ];
    let currentTolerance = 0;
    
    let lastHitEnemy = null;
    let mouseX = 0, mouseY = 0;
    let wave = 1;
    let score = 0;
    let currentMap = 0;
    let backgroundImage = null;
    let backgroundGrid = [];
    let enemyIdCounter = 0;

    // Efectos visuales temporales
    const effects = [];

    const gridCols = 8;
    const gridRows = 6;
    const cellWidth = canvas.width / gridCols;
    const cellHeight = canvas.height / gridRows;

    // Variables de Cooldown y Carga
    let lastSlashTime = 0;
    const slashCooldown = 250; // 0.25 segundos en milisegundos (usado para Corte Curvo)

    let lastBurstTime = 0; // NUEVO: Tiempo del último Ráfaga de Pintura
    const burstCooldown = 3000; // NUEVO: Cooldown de segundos para Ráfaga de Pintura

    let lastExplosionTime = 0;
    const explosionCooldown = 3000; // 3.0 segundo en milisegundos

    let leftMouseDownTime = 0;
    const chargeTime = 500; // 0.5 segundos para cargar la ráfaga
    let isCharged = false;

    // NUEVAS VARIABLES PARA VERIFICACIÓN MANUAL
    let lastCheckTime = 0;
    const checkCooldown = 500; // 0.5 segundos entre verificaciones
    let darkenEffect = 0;
    const DARKEN_DURATION = 15; // frames que dura el efecto

    function debug(msg) {
      debugInfo.textContent = `Debug: ${msg}`;
    }
    
    function loadBackgroundImage(url) {
      return new Promise((resolve, reject) => {
        debug(`Cargando imagen: ${url}`);
        
        const img = new Image();
        img.crossOrigin = "Anonymous";
        
        img.onload = () => {
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = gridCols;
          tempCanvas.height = gridRows;
          const tempCtx = tempCanvas.getContext('2d');
          
          tempCtx.imageSmoothingEnabled = false;
          tempCtx.drawImage(img, 0, 0, gridCols, gridRows);
          
          const imageData = tempCtx.getImageData(0, 0, gridCols, gridRows);
          const data = imageData.data;
          
          backgroundGrid = [];
          for (let row = 0; row < gridRows; row++) {
            backgroundGrid[row] = [];
            for (let col = 0; col < gridCols; col++) {
              const index = (row * gridCols + col) * 4;
              
              backgroundGrid[row][col] = {
                r: data[index],
                g: data[index + 1],
                b: data[index + 2],
                used: false
              };
            }
          }
          
          backgroundImage = img;
          debug("Cuadrícula procesada exitosamente");
          resolve();
        };
        
        img.onerror = (e) => {
          debug(`ERROR cargando imagen: ${url}`);
          reject(new Error(`No se pudo cargar: ${url}`));
        };
        
        img.src = url;
      });
    }

    function nextMap() {
      fallenBlocks.length = 0;
      debug("Bloques caídos limpiados");
      
      currentMap = (currentMap + 1) % predefinedMaps.length;
      const map = predefinedMaps[currentMap];
      
      debug(`Cambiando a mapa: ${map.name}`);
      
      return loadBackgroundImage(map.url).then(() => {
        mapInfo.textContent = `Mapa: ${map.name}`;
      }).catch((error) => {
        mapInfo.textContent = `Mapa: Error (${map.name})`;
        console.error(error);
        throw error;
      });
    }

    function getBackgroundColorAt(x, y) {
      const col = Math.floor(x / cellWidth);
      const row = Math.floor(y / cellHeight);
      
      if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
        const cell = backgroundGrid[row][col];
        return {
            color: cell,
            gridId: `${row}-${col}`,
            gridRow: row,
            gridCol: col,
            gridX: col * cellWidth,
            gridY: row * cellHeight,
            isUsed: cell.used
        };
      }
      return {color: {r: 0, g: 0, b: 0, used: false}, gridId: null, gridRow: -1, gridCol: -1, isUsed: true};
    }
    
    function getBackgroundColorWithFallenBlocksAt(x, y) {
      for (let i = 0; i < fallenBlocks.length; i++) {
        const block = fallenBlocks[i];
        if (x >= block.x && x <= block.x + block.width &&
            y >= block.y && y <= block.y + block.height) {
          return block.color;
        }
      }
      return getBackgroundColorAt(x, y).color;
    }

    function canMoveTo(x, y) {
      const corners = [
        {x: x, y: y},
        {x: x + player.size, y: y},
        {x: x, y: y + player.size},
        {x: x + player.size, y: y + player.size}
      ];
      
      return corners.every(corner => {
        const bgColor = getBackgroundColorWithFallenBlocksAt(corner.x, corner.y);
        return !isColorSimilar(bgColor, {r: 0, g: 0, b: 0});
      });
    }

    function drawBackground() {
      if (backgroundImage) {
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
      }
    }

    function drawFallenBlocks() {
      fallenBlocks.forEach(block => {
        ctx.fillStyle = rgb(block.color);
        ctx.fillRect(block.x, block.y, block.width, block.height);
        
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.strokeRect(block.x, block.y, block.width, block.height);
      });
    }

    // NUEVA FUNCIÓN: Generar formas conectadas aleatorias
    function generateRandomShape() {
      const maxSize = 20;
      const minBlocks = 12;
      const maxBlocks = 30;
      
      // Determinar tamaño de la forma
      const width = Math.floor(Math.random() * (maxSize - 3)) + 3;
      const height = Math.floor(Math.random() * (maxSize - 3)) + 3;
      const totalBlocks = Math.floor(Math.random() * (maxBlocks - minBlocks)) + minBlocks;
      
      // Crear grid vacío
      const grid = Array(height).fill().map(() => Array(width).fill(0));
      
      // Empezar desde un punto aleatorio
      const startX = Math.floor(Math.random() * width);
      const startY = Math.floor(Math.random() * height);
      
      // Algoritmo de crecimiento para asegurar conectividad
      const blocks = [{x: startX, y: startY}];
      grid[startY][startX] = 1;
      
      const directions = [
        {dx: -1, dy: 0}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: 0, dy: 1},
        {dx: -1, dy: -1}, {dx: -1, dy: 1}, {dx: 1, dy: -1}, {dx: 1, dy: 1}
      ];
      
      while (blocks.length < totalBlocks && blocks.length < width * height) {
        // Elegir un bloque existente aleatorio
        const randomBlock = blocks[Math.floor(Math.random() * blocks.length)];
        
        // Mezclar direcciones
        const shuffledDirections = [...directions].sort(() => Math.random() - 0.5);
        
        let added = false;
        for (const dir of shuffledDirections) {
          const newX = randomBlock.x + dir.dx;
          const newY = randomBlock.y + dir.dy;
          
          if (newX >= 0 && newX < width && newY >= 0 && newY < height && grid[newY][newX] === 0) {
            blocks.push({x: newX, y: newY});
            grid[newY][newX] = 1;
            added = true;
            break;
          }
        }
        
        // Si no se pudo agregar desde este bloque, continuar con otro
        if (!added) {
          // Buscar cualquier bloque adyacente disponible
          for (const block of blocks) {
            for (const dir of directions) {
              const newX = block.x + dir.dx;
              const newY = block.y + dir.dy;
              
              if (newX >= 0 && newX < width && newY >= 0 && newY < height && grid[newY][newX] === 0) {
                blocks.push({x: newX, y: newY});
                grid[newY][newX] = 1;
                added = true;
                break;
              }
            }
            if (added) break;
          }
        }
        
        // Si realmente no hay bloques disponibles, terminar
        if (!added) break;
      }
      
      return {
        blocks: blocks,
        width: width,
        height: height
      };
    }

    function createEnemy() {
      const shape = generateRandomShape();
      const blockSize = 6; // Tamaño ligeramente reducido para formas más grandes
      
      // Calcular ancho y alto real en píxeles
      const pixelWidth = shape.width * blockSize;
      const pixelHeight = shape.height * blockSize;
      
      // Posición inicial - asegurar que quepa en pantalla
      const x = Math.random() * (canvas.width - pixelWidth);
      const y = Math.random() * 150; // Parte superior de la pantalla
      
      enemyIdCounter++;
      
      // Crear bloques basados en la forma generada
      const blocks = shape.blocks.map(blockPos => ({
        color: {r:255, g:255, b:255},
        painted: false,
        relX: blockPos.x,
        relY: blockPos.y
      }));
      
      return {
        id: enemyIdCounter,
        x: x,
        y: y,
        blockWidth: blockSize,
        blockHeight: blockSize,
        blocks: blocks,
        shapeWidth: shape.width,
        shapeHeight: shape.height,
        baseSpeed: 0.08, // Velocidad reducida para enemigos más grandes
        currentSpeed: 0.08,
        fastSpeed: 0.2,
        active: true,
        directionChangeTime: 0,
        randomAngle: Math.random() * Math.PI * 2,
        hasBeenHit: false
      };
    }

    function getEnemyWidth(enemy) {
      return enemy.shapeWidth * enemy.blockWidth;
    }

    function getEnemyHeight(enemy) {
      return enemy.shapeHeight * enemy.blockHeight;
    }

    function initWave() {
      enemies.length = 0;
      const enemyCount = 2 + Math.floor(wave * 0.7); // Menos enemigos por oleada para compensar tamaño
      for(let i = 0; i < enemyCount; i++) {
        let newEnemy;
        let validPosition = false;
        let attempts = 0;
        
        while (!validPosition && attempts < 50) {
          newEnemy = createEnemy();
          validPosition = true;
          
          for (let j = 0; j < enemies.length; j++) {
            const dx = newEnemy.x - enemies[j].x;
            const dy = newEnemy.y - enemies[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = (getEnemyWidth(newEnemy) + getEnemyWidth(enemies[j])) * 0.7;
            
            if (distance < minDistance) {
              validPosition = false;
              break;
            }
          }
          attempts++;
        }
        
        enemies.push(newEnemy);
      }
      waveInfo.textContent = `Oleada: ${wave} | Enemigos: ${enemyCount}`;
    }

    function rgb(c){return `rgb(${Math.round(c.r)},${Math.round(c.g)},${Math.round(c.b)})`;}

    function mixColor(base, added, opacity){
      return {
        r: base.r*(1-opacity) + added.r*opacity,
        g: base.g*(1-opacity) + added.g*opacity,
        b: base.b*(1-opacity) + added.b*opacity
      };
    }

    function isColorSimilar(c1, c2) {
      const dR = c1.r - c2.r;
      const dG = c1.g - c2.g;
      const dB = c1.b - c2.b;
      const distance = Math.sqrt(dR*dR + dG*dG + dB*dB);
      const toleranceValue = toleranceLevels[currentTolerance].value * 2.2;
      return distance <= toleranceValue;
     }
    
    // ATAQUE 1: Corte Curvo (Click Izquierdo Rápido)
    function performCurvedSlash() {
      const now = Date.now();
      if (now - lastSlashTime < slashCooldown) return; // Cooldown
      
      if (!selectedColor) return;

      lastSlashTime = now; // Reiniciar cooldown
      
      const playerCenterX = player.x + player.size / 2;
      const playerCenterY = player.y + player.size / 2;
      const dxMouse = mouseX - canvas.width / 2;
      const dyMouse = mouseY - canvas.height / 2;
      const mouseDist = Math.sqrt(dxMouse * dxMouse + dyMouse * dyMouse);
      const slashMax = 80; // configurable
      const slashRadius = Math.min(mouseDist, slashMax);
      const slashThickness = 10; // grosor del borde activo

      
      // Calcular ángulo hacia el mouse (respecto al centro de la pantalla, que es el centro visual)
      const angle = Math.atan2(mouseY - (canvas.height/2), mouseX - (canvas.width/2));
      
      // Ángulos del arco: 45 grados a cada lado (PI/4)
      const startAngle = angle - Math.PI/4; 
      const endAngle = angle + Math.PI/4;
      
      // Crear efecto visual de corte curvo
      effects.push({
        type: 'slash',
        x: playerCenterX,
        y: playerCenterY,
        angle: angle,
        radius: slashRadius,
        startAngle: startAngle,
        endAngle: endAngle,
        color: selectedColor,
        opacity: opacity,
        life: 20
      });
      
      // Aplicar color a bloques enemigos en el área del corte
      enemies.forEach(enemy => {
        if (!enemy.active) return;
        
        let enemyHit = false;

        // Iterar sobre cada bloque del enemigo
        enemy.blocks.forEach((block) => {
          // Calcular la posición central del bloque en el mundo
          const blockWorldX = enemy.x + block.relX * enemy.blockWidth;
          const blockWorldY = enemy.y + block.relY * enemy.blockHeight;
          const blockCenterX = blockWorldX + enemy.blockWidth / 2;
          const blockCenterY = blockWorldY + enemy.blockHeight / 2;
          
          // Calcular distancia y ángulo del bloque al jugador
          const dx = blockCenterX - playerCenterX;
          const dy = blockCenterY - playerCenterY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const blockAngle = Math.atan2(dy, dx);
          
          // 1. Verificar distancia
          if (distance >= slashRadius - slashThickness && distance <= slashRadius) {
       
            // 2. Verificar ángulo (si está dentro de la rebanada)
            // La función Math.atan2(sin, cos) ayuda a obtener la diferencia angular correcta
            // Normalizar el ángulo a [-PI, PI]
            let angleDiff = blockAngle - angle;
            if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
            
            if (Math.abs(angleDiff) <= Math.PI/4) { // Menor o igual a 45 grados
              block.color = mixColor(block.color, selectedColor, opacity);
              block.painted = true;
              enemyHit = true;
            }
          }
        });

        if (enemyHit) {
            lastHitEnemy = enemy;
            if (!enemy.hasBeenHit) {
                enemy.hasBeenHit = true;
                enemy.currentSpeed = enemy.fastSpeed;
            }
        }
      });
    }

   // ATAQUE 2: Ráfaga de Pintura (Instantánea con retardo de 0.25s)
function launchPaintBurst() {
  if (!selectedColor) return;

  const now = Date.now();
  if (now - lastBurstTime < burstCooldown) return; // Cooldown
  lastBurstTime = now;

  // Espera 0.25s antes de ejecutar
  setTimeout(() => {
    const playerCenterX = player.x + player.size / 2;
    const playerCenterY = player.y + player.size / 2;

    const angle = Math.atan2(mouseY - (canvas.height / 2), mouseX - (canvas.width / 2));
    const burstLength = 300;
    const burstWidth = 12;

    // Coordenadas finales del trazo
    const endX = playerCenterX + Math.cos(angle) * burstLength;
    const endY = playerCenterY + Math.sin(angle) * burstLength;

    // Aplicar pintura a enemigos en el trayecto
    enemies.forEach(enemy => {
      if (!enemy.active) return;

      enemy.blocks.forEach((block) => {
        const blockWorldX = enemy.x + block.relX * enemy.blockWidth;
        const blockWorldY = enemy.y + block.relY * enemy.blockHeight;
        const bx = blockWorldX + enemy.blockWidth / 2;
        const by = blockWorldY + enemy.blockHeight / 2;

        // Distancia perpendicular del bloque a la línea del trazo
        const dx = bx - playerCenterX;
        const dy = by - playerCenterY;
        const proj = dx * Math.cos(angle) + dy * Math.sin(angle);
        const perp = -dx * Math.sin(angle) + dy * Math.cos(angle);

        // Si está dentro del rango longitudinal y transversal del rayo
        if (proj >= 0 && proj <= burstLength && Math.abs(perp) <= burstWidth) {
          block.color = mixColor(block.color, selectedColor, opacity);
          block.painted = true;
          enemy.hasBeenHit = true;
          enemy.currentSpeed = enemy.fastSpeed;
        }
      });
    });

    // Efecto visual: línea de color (persistencia rápida)
    effects.push({
      type: 'burstLine',
      x1: playerCenterX,
      y1: playerCenterY,
      x2: endX,
      y2: endY,
      color: selectedColor,
      opacity: opacity,
      life: 15
    });
  }, 250);
}

    // ATAQUE 3: Explosión de Color (Click Derecho)
    function performColorExplosion() {
      const now = Date.now();
      if (now - lastExplosionTime < explosionCooldown) return; // Cooldown
      
      if (!selectedColor) return;

      lastExplosionTime = now; // Reiniciar cooldown
      
      const playerCenterX = player.x + player.size / 2;
      const playerCenterY = player.y + player.size / 2;
      const explosionRadius = 40;
      
      // Crear efecto visual de explosión
      effects.push({
        type: 'explosion',
        x: playerCenterX,
        y: playerCenterY,
        radius: explosionRadius,
        color: selectedColor,
        opacity: opacity,
        life: 15
      });
      
      // Aplicar color a bloques enemigos en el área de explosión
      enemies.forEach(enemy => {
        if (!enemy.active) return;
        
        let enemyHit = false;
        
        // Iterar sobre cada bloque del enemigo
        enemy.blocks.forEach((block) => {
          const blockWorldX = enemy.x + block.relX * enemy.blockWidth;
          const blockWorldY = enemy.y + block.relY * enemy.blockHeight;
          
          // Lógica de colisión Círculo/Rectángulo: encontrar el punto más cercano del bloque al centro de la explosión
          const closestX = Math.max(blockWorldX, Math.min(playerCenterX, blockWorldX + enemy.blockWidth));
          const closestY = Math.max(blockWorldY, Math.min(playerCenterY, blockWorldY + enemy.blockHeight));
          
          // Calcular distancia entre el punto más cercano y el centro de la explosión
          const dx = closestX - playerCenterX;
          const dy = closestY - playerCenterY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // Verificar colisión
          if (distance <= explosionRadius) {
            block.color = mixColor(block.color, selectedColor, opacity);
            block.painted = true;
            enemyHit = true;
          }
        });
        
        if (enemyHit) {
            lastHitEnemy = enemy;
            if (!enemy.hasBeenHit) {
                enemy.hasBeenHit = true;
                enemy.currentSpeed = enemy.fastSpeed;
            }
        }
      });
    }
    
    // ACTUALIZADO: Función para mover y colisionar proyectiles (SIN LÍMITE DE BLOQUES PINTADOS)
    function updateProjectiles() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            
            if (!p.active) continue;
            
            const dx = Math.cos(p.angle) * p.speed;
            const dy = Math.sin(p.angle) * p.speed;
            
            p.x += dx;
            p.y += dy;
            p.distanceTraveled += Math.sqrt(dx * dx + dy * dy);

            // 1. Colisión con enemigos (AHORA ATRAVIESA Y PINTA TODOS LOS BLOQUES COLISIONADOS)
            enemies.forEach(enemy => {
                if (!enemy.active || p.hitEnemies.has(enemy.id)) return;

                const enemyWidth = getEnemyWidth(enemy);
                const enemyHeight = getEnemyHeight(enemy);

                // Colisión Círculo/Rectángulo (Bounding Box del enemigo completo)
                const closestX = Math.max(enemy.x, Math.min(p.x, enemy.x + enemyWidth));
                const closestY = Math.max(enemy.y, Math.min(p.y, enemy.y + enemyHeight));

                const distSq = (p.x - closestX) * (p.x - closestX) + (p.y - closestY) * (p.y - closestY);

                if (distSq < (p.size / 2) * (p.size / 2)) {
                    
                    let enemyHit = false;
                    let blocksPainted = 0;
                    
                    // LÓGICA DE PINTURA MEJORADA: Pinta TODOS los bloques que colisionen con el proyectil (SIN LÍMITES)
                    enemy.blocks.forEach((block) => {
                        const blockWorldX = enemy.x + block.relX * enemy.blockWidth;
                        const blockWorldY = enemy.y + block.relY * enemy.blockHeight;
                        const blockWorldWidth = enemy.blockWidth;
                        const blockWorldHeight = enemy.blockHeight;

                        // Colisión Círculo/Rectángulo: encontrar el punto más cercano del bloque al centro del proyectil
                        const closestBlockX = Math.max(blockWorldX, Math.min(p.x, blockWorldX + blockWorldWidth));
                        const closestBlockY = Math.max(blockWorldY, Math.min(p.y, blockWorldY + blockWorldHeight));

                        // Calcular distancia entre el punto más cercano y el centro del proyectil
                        const dxBlock = closestBlockX - p.x;
                        const dyBlock = closestBlockY - p.y;
                        const distanceBlockSq = dxBlock * dxBlock + dyBlock * dyBlock;
                        
                        // Verificar colisión con el radio del proyectil (p.size / 2)
                        if (distanceBlockSq < (p.size / 2) * (p.size / 2)) {
                            block.color = mixColor(block.color, p.color, p.opacity);
                            block.painted = true;
                            enemyHit = true;
                            blocksPainted++;
                        }
                    });
                    
                    // Debug opcional: mostrar cuántos bloques fueron pintados
                    if (blocksPainted > 0) {
                        debug(`Burst pintó ${blocksPainted} bloques`);
                    }
                    
                    if (enemyHit) {
                        lastHitEnemy = enemy;
                        if (!enemy.hasBeenHit) {
                            enemy.hasBeenHit = true;
                            enemy.currentSpeed = enemy.fastSpeed;
                        }
                    }
                    
                    // MARCAR ENEMIGO COMO IMPACTADO PARA ESTE TICK (Permite el paso, ya que atraviesa)
                    p.hitEnemies.add(enemy.id); 
                }
            });

            // 2. Límite de distancia (el proyectil se desactiva cuando se acaba su alcance)
            if (p.distanceTraveled > p.maxDistance) {
                p.active = false;
            }

            // 3. Eliminar proyectiles inactivos
            if (!p.active) {
                effects.push({
                    type: 'explosion',
                    x: p.x,
                    y: p.y,
                    radius: 15,
                    color: p.color,
                    opacity: p.opacity,
                    life: 10
                });
                projectiles.splice(i, 1);
            }
        }
    }
    
    // NUEVA FUNCIÓN: Verificación manual de colores
    function performManualColorCheck() {
        const now = Date.now();
        if (now - lastCheckTime < checkCooldown) return;
        
        lastCheckTime = now;
        darkenEffect = DARKEN_DURATION; // Activar efecto visual
        
        let totalBlocksChecked = 0;
        let matchesFound = 0;
        let blocksRemoved = 0;

        enemies.forEach(enemy => {
            if (!enemy.active) return;

            // Solo verificar enemigos cercanos (optimización)
            if (!isEnemyNearPlayer(enemy, 400)) return;

            for (let i = enemy.blocks.length - 1; i >= 0; i--) {
                const block = enemy.blocks[i];
                if (!block) continue;

                totalBlocksChecked++;

                // Solo verificar bloques suficientemente pintados
                if (!isBlockSufficientlyPainted(block)) continue;

                const blockWorldX = enemy.x + block.relX * enemy.blockWidth;
                const blockWorldY = enemy.y + block.relY * enemy.blockHeight;

                const bgInfo = getBackgroundColorAt(blockWorldX + enemy.blockWidth/2, blockWorldY + enemy.blockHeight/2);
                const bgColor = bgInfo.color;

                // Muestreo optimizado - solo puntos centrales
                const samplePoints = [
                    {x: blockWorldX + enemy.blockWidth * 0.5, y: blockWorldY + enemy.blockHeight * 0.5}
                ];

                let matchCount = 0;
                samplePoints.forEach(p => {
                    const sampleColor = getBackgroundColorAt(p.x, p.y).color;
                    if (isColorSimilar(block.color, sampleColor)) matchCount++;
                });

                const matchRatio = matchCount / samplePoints.length;

                if (bgInfo.gridId !== null && matchRatio >= 0.5) {
                    backgroundGrid[bgInfo.gridRow][bgInfo.gridCol].used = true;

                    fallenBlocks.push({
                        x: blockWorldX,
                        y: blockWorldY,
                        width: enemy.blockWidth,
                        height: enemy.blockHeight,
                        color: {...block.color},
                        enemyId: enemy.id 
                    });

                    enemy.blocks.splice(i, 1);
                    score += 5;
                    matchesFound++;
                    blocksRemoved++;
                    checkVictory(enemy);
                }
            }
        });

        // Feedback de debug
        if (totalBlocksChecked > 0) {
            debug(`Escaneo: ${totalBlocksChecked} bloques → ${matchesFound} coincidencias, ${blocksRemoved} removidos`);
        } else {
            debug("Escaneo: Sin bloques para verificar");
        }
    }

    // NUEVA FUNCIÓN: Verificar proximidad del enemigo
    function isEnemyNearPlayer(enemy, maxDistance = 400) {
        const enemyCenterX = enemy.x + getEnemyWidth(enemy) / 2;
        const enemyCenterY = enemy.y + getEnemyHeight(enemy) / 2;
        const playerCenterX = player.x + (player.size / 2);
        const playerCenterY = player.y + (player.size / 2);
        
        const dx = enemyCenterX - playerCenterX;
        const dy = enemyCenterY - playerCenterY;
        return Math.sqrt(dx * dx + dy * dy) <= maxDistance;
    }

    // NUEVA FUNCIÓN: Detectar bloques pintados
    function isBlockSufficientlyPainted(block) {
        if (!block) return false;
        
        // Detectar cualquier cambio del blanco puro
        const white = {r: 255, g: 255, b: 255};
        const difference = Math.abs(block.color.r - white.r) + 
                          Math.abs(block.color.g - white.g) + 
                          Math.abs(block.color.b - white.b);
        
        // Umbral bajo - cualquier pintura cuenta
        return difference > 10;
    }

    // NUEVA FUNCIÓN: Teñir enemigo completamente de blanco
    function whitenLastEnemy() {
        if (!lastHitEnemy) return;
        
        lastHitEnemy.blocks.forEach(block => {
            block.color = {r:255, g:255, b:255};
            block.painted = false;
        });
        lastHitEnemy.currentSpeed = lastHitEnemy.baseSpeed;
        lastHitEnemy.hasBeenHit = false;
        
        debug("Enemigo revertido a blanco");
    }

    // NUEVA FUNCIÓN: Teñir enemigo completamente de negro
    function blackenLastEnemy() {
        if (!lastHitEnemy) return;
        
        lastHitEnemy.blocks.forEach(block => {
            block.color = {r:0, g:0, b:0};
            block.painted = true; // Marcar como pintado para que el escaneo lo considere
        });
        
        debug("Enemigo teñido de negro");
    }

    // NUEVA FUNCIÓN: Cambiar modo de color
    function toggleColorMode() {
        colorMode = colorMode === 'RGB' ? 'MYC' : 'RGB';
        selectedColor = null; // Deseleccionar color al cambiar modo
        opacity = 0.1;
        hud.textContent = `Modo: ${colorMode} | Color: Ninguno | Opacidad: ${Math.round(opacity*100)}%`;
        debug(`Modo de color cambiado a: ${colorMode}`);
    }

// Partículas blancas del enemigo al jugador
        if (lastHitEnemy) {
          const enemyCenterX = lastHitEnemy.x + getEnemyWidth(lastHitEnemy) / 2;
          const enemyCenterY = lastHitEnemy.y + getEnemyHeight(lastHitEnemy) / 2;
          const playerCenterX = player.x + player.size / 2;
          const playerCenterY = player.y + player.size / 2;

          for (let i = 0; i < 12; i++) {
          effects.push({
          type: 'particle',
          x: enemyCenterX,
          y: enemyCenterY,
          dx: (playerCenterX - enemyCenterX) / 15 + (Math.random() - 0.5) * 2,
          dy: (playerCenterY - enemyCenterY) / 15 + (Math.random() - 0.5) * 2,
          color: {r:255,g:255,b:255},
          life: 15
        });
      }
    }
 
    // Dibujar efectos visuales y Proyectiles
    function drawEffects() {
      // -----------------
      // Dibujar Proyectiles
      // -----------------
      projectiles.forEach(p => {
          ctx.save();
          ctx.fillStyle = rgb(p.color);
          ctx.globalAlpha = p.opacity;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
      });

      // -----------------
      // Dibujar Efectos (Slash, Explosion, etc.)
      // -----------------
      for (let i = effects.length - 1; i >= 0; i--) {
        const effect = effects[i];
        
        ctx.save();
        ctx.globalAlpha = effect.opacity * (effect.life / 20);
        
        if (effect.type === 'slash') {
          // Dibujar arco para el corte curvo
          ctx.strokeStyle = rgb(effect.color);
          ctx.lineWidth = 8;
          ctx.beginPath();
          ctx.arc(effect.x, effect.y, effect.radius, effect.startAngle, effect.endAngle);
          ctx.stroke();
          
          // Dibujar línea central más intensa
          ctx.strokeStyle = rgb(effect.color);
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(effect.x, effect.y);
          ctx.lineTo(
            effect.x + Math.cos(effect.angle) * effect.radius,
            effect.y + Math.sin(effect.angle) * effect.radius
          );
          ctx.stroke();
        } else if (effect.type === 'explosion') {
          // Dibujar círculo para la explosión
          ctx.fillStyle = rgb(effect.color);
          ctx.beginPath();
          ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
          ctx.fill();
          
          // Dibujar borde
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        
        else if (effect.type === 'burstLine') {
          ctx.strokeStyle = rgb(effect.color);
          ctx.globalAlpha = effect.opacity * (effect.life / 15);
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.moveTo(effect.x1, effect.y1);
          ctx.lineTo(effect.x2, effect.y2);
          ctx.stroke();
        }

        ctx.restore();
        
        // Reducir vida del efecto
        effect.life--;
        if (effect.life <= 0) {
          effects.splice(i, 1);
        }

else if (effect.type === 'particle') {
  ctx.fillStyle = rgb(effect.color);
  ctx.globalAlpha = effect.life / 15;
  ctx.beginPath();
  ctx.arc(effect.x, effect.y, 2, 0, Math.PI * 2);
  ctx.fill();
  effect.x += effect.dx;
  effect.y += effect.dy;
  effect.life--;
}

      }

      // -----------------
      // Indicador de Carga
      // -----------------
      if (leftMouseDownTime > 0) {
          const chargeElapsed = Date.now() - leftMouseDownTime;
          const chargeRatio = Math.min(chargeElapsed / chargeTime, 1);
          
          if (chargeRatio >= 1) {
              isCharged = true;
          }

          if (chargeRatio > 0.1) {
              const indicatorSize = player.size + 10 + 20 * chargeRatio;
              ctx.save();
              ctx.globalAlpha = 0.5 + 0.5 * chargeRatio;
              ctx.strokeStyle = isCharged ? 'yellow' : 'cyan';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(player.x + player.size/2, player.y + player.size/2, indicatorSize / 2, 0, Math.PI * 2 * chargeRatio);
              ctx.stroke();
              ctx.restore();
          }
      }
    }
    
    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save();
      
      // Aplicar efecto de oscurecimiento si está activo
      if (darkenEffect > 0) {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.scale(zoomLevel, zoomLevel);
      ctx.translate(-(player.x + player.size / 2), -(player.y + player.size / 2));

      drawBackground();
      drawFallenBlocks();
      
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.size, player.size);

      enemies.forEach(enemy => {
        if(!enemy.active) return;
        
        enemy.blocks.forEach((block) => {
          ctx.fillStyle = rgb(block.color);
          
          const worldX = enemy.x + block.relX * enemy.blockWidth;
          const worldY = enemy.y + block.relY * enemy.blockHeight;
          
          ctx.fillRect(worldX, worldY, enemy.blockWidth, enemy.blockHeight);
        });
        
        // Dibujar bounding box para debugging (opcional)
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.strokeRect(enemy.x, enemy.y, getEnemyWidth(enemy), getEnemyHeight(enemy));
      });

      // Dibujar efectos y proyectiles
      drawEffects();

      ctx.restore();
      
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, canvas.height / 2);
      ctx.lineTo(mouseX, mouseY);
      ctx.stroke();
      
      ctx.fillStyle = 'white';
      ctx.font = '16px Arial';
      ctx.fillText(`Puntuación: ${score}`, 20, canvas.height - 20);
      ctx.fillText(`Tolerancia: ${toleranceLevels[currentTolerance].name}`, 20, canvas.height - 45);
      ctx.fillText(`[ESPACIO] para escanear`, 20, canvas.height - 70);
      ctx.fillText(`[E] Blanco | [Q] Negro`, 20, canvas.height - 95);
      ctx.fillText(`[4] Cambiar a ${colorMode === 'RGB' ? 'MYC' : 'RGB'}`, 20, canvas.height - 120);
    }

    function update(){
      // Reducir el efecto de oscurecimiento
      if (darkenEffect > 0) {
          darkenEffect--;
      }

      // SOLO MOVIMIENTO - NO VERIFICACIÓN DE COLORES
      const now = Date.now();
      enemies.forEach(enemy => {
        if (!enemy.active) return;
        
        const enemyWidth = getEnemyWidth(enemy);
        const enemyHeight = getEnemyHeight(enemy);
        
        if (now - enemy.directionChangeTime > 1500) {
          enemy.randomAngle = Math.random() * Math.PI * 2;
          enemy.directionChangeTime = now;
        }
        
        enemy.x += Math.cos(enemy.randomAngle) * enemy.currentSpeed;
        enemy.y += Math.sin(enemy.randomAngle) * enemy.currentSpeed;
        
        // LÍMITES DE PANTALLA - Los enemigos no pueden salir del canvas
        const margin = 5;
        if (enemy.x < margin) {
          enemy.x = margin;
          enemy.randomAngle = Math.PI - enemy.randomAngle;
        } else if (enemy.x > canvas.width - enemyWidth - margin) {
          enemy.x = canvas.width - enemyWidth - margin;
          enemy.randomAngle = Math.PI - enemy.randomAngle;
        }
        
        if (enemy.y < margin) {
          enemy.y = margin;
          enemy.randomAngle = -enemy.randomAngle;
        } else if (enemy.y > canvas.height - enemyHeight - margin) {
          enemy.y = canvas.height - enemyHeight - margin;
          enemy.randomAngle = -enemy.randomAngle;
        }
        
        // Asegurar que no se salgan por completo
        enemy.x = Math.max(0, Math.min(canvas.width - enemyWidth, enemy.x));
        enemy.y = Math.max(0, Math.min(canvas.height - enemyHeight, enemy.y));
        
        // Colisiones entre enemigos
        enemies.forEach(otherEnemy => {
          if (otherEnemy !== enemy && otherEnemy.active) {
            const otherEnemyWidth = getEnemyWidth(otherEnemy);
            const otherEnemyHeight = getEnemyHeight(otherEnemy);
            const dx = enemy.x - otherEnemy.x;
            const dy = enemy.y - otherEnemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = (enemyWidth + otherEnemyWidth) / 2;
            
            if (distance < minDistance) {
              const angle = Math.atan2(dy, dx);
              const pushForce = (minDistance - distance) / minDistance * enemy.currentSpeed;
              
              enemy.x += Math.cos(angle) * pushForce;
              enemy.y += Math.sin(angle) * pushForce;
              otherEnemy.x -= Math.cos(angle) * pushForce;
              otherEnemy.y -= Math.sin(angle) * pushForce;
            }
          }
        });
      });
      
      updateProjectiles();
    }

    function checkVictory(enemy){
      if(enemy.blocks.length === 0) {
        enemy.active = false;
        score += 50;
        
        if(enemies.every(e => !e.active)) {
          wave++;
          setTimeout(() => {
            nextMap().then(() => {
                initWave();
            }).catch(e => debug("Fallo al cargar mapa después de victoria."));
          }, 1000);
        }
      }
    }

    const keys = {};
    document.addEventListener('keydown', e=>{
      keys[e.key] = true;
      
      const activeColors = getActiveColors();
      
      if(activeColors[e.key]){
        if(selectedColor !== activeColors[e.key]){
          selectedColor = activeColors[e.key];
          opacity = 0.1;
        } else {
          opacity = Math.min(opacity+0.1,1);
        }
        hud.textContent = `Modo: ${colorMode} | Color: ${selectedColor.name} | Opacidad: ${Math.round(opacity*100)}%`;
      }
      
      // NUEVA TECLA: ESPACIO para verificación manual
      if(e.key === ' ' || e.key === 'Spacebar') {
        performManualColorCheck();
      }
      
      // NUEVA TECLA: E para blanquear enemigo
      if(e.key === 'e' || e.key === 'E') {
        whitenLastEnemy();
      }

// Partículas blancas del jugador al enemigo
if (lastHitEnemy) {
  const enemyCenterX = lastHitEnemy.x + getEnemyWidth(lastHitEnemy) / 2;
  const enemyCenterY = lastHitEnemy.y + getEnemyHeight(lastHitEnemy) / 2;
  const playerCenterX = player.x + player.size / 2;
  const playerCenterY = player.y + player.size / 2;

  for (let i = 0; i < 12; i++) {
    effects.push({
      type: 'particle',
      x: playerCenterX,
      y: playerCenterY,
      dx: (enemyCenterX - playerCenterX) / 15 + (Math.random() - 0.5) * 2,
      dy: (enemyCenterY - playerCenterY) / 15 + (Math.random() - 0.5) * 2,
      color: {r:255,g:255,b:255},
      life: 15
    });
  }
}
      
      // NUEVA TECLA: Q para ennegrecer enemigo
      if(e.key === 'q' || e.key === 'Q') {
        blackenLastEnemy();
      }
      
      // NUEVA TECLA: 4 para cambiar modo de color
      if(e.key === '4') {
        toggleColorMode();
      }
      
      if(e.key === 'ArrowUp') {
        currentTolerance = Math.min(currentTolerance + 1, toleranceLevels.length - 1);
        toleranceInfo.textContent = `Tolerancia: ${toleranceLevels[currentTolerance].name} (▲/▼ para ajustar)`;
      }
      if(e.key === 'ArrowDown') {
        currentTolerance = Math.max(currentTolerance - 1, 0);
        toleranceInfo.textContent = `Tolerancia: ${toleranceLevels[currentTolerance].name} (▲/▼ para ajustar)`;
      }
      
      if(e.key === 'm') {
        nextMap().then(initWave);
      }
      
      if(e.key === 'z') {
        zoomLevel = Math.min(zoomLevel + 0.1, 3.0);
        debug(`Zoom: ${zoomLevel.toFixed(1)}x`);
      }
      if(e.key === 'x') {
        zoomLevel = Math.max(zoomLevel - 0.1, 1.0);
        debug(`Zoom: ${zoomLevel.toFixed(1)}x`);
      }
    });
    
    document.addEventListener('keyup', e=> {
      keys[e.key] = false;
    });

    canvas.addEventListener('mousemove', e=>{
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });
    
    // Manejo de MOUSE DOWN (Inicio de carga)
    canvas.addEventListener('mousedown', e=>{
      if(!selectedColor) return;
      
      if(e.button === 0) { // Click izquierdo - Inicia la carga
          const now = Date.now();
          if (now - lastSlashTime < slashCooldown) return; 

          leftMouseDownTime = now;
          isCharged = false;

      } else if(e.button === 2) { // Click derecho - Explosión de color
        performColorExplosion();
      }
    });

    // Manejo de MOUSE UP (Lanzamiento/Ataque normal)
    canvas.addEventListener('mouseup', e => {
        if (!selectedColor) return;

        if (e.button === 0) { // Click izquierdo - Finaliza la carga / Lanza ataque
            const now = Date.now();
            const holdDuration = now - leftMouseDownTime;

            if (leftMouseDownTime === 0) return; // Si no se registró el mousedown, ignorar

            if (isCharged || holdDuration >= chargeTime) {
                // ATAQUE CARGADO: Lanza Ráfaga de Pintura (Cooldown independiente)
                launchPaintBurst();
            } else {
                // ATAQUE NORMAL: Lanza Corte Curvo (Cooldown compartido con carga)
                performCurvedSlash();
            }

            // Reiniciar estado de carga
            leftMouseDownTime = 0;
            isCharged = false;
        }
    });
    
    // Prevenir el menú contextual al hacer click derecho
    canvas.addEventListener('contextmenu', e=>{
      e.preventDefault();
    });

    function movePlayer(){
      let newX = player.x;
      let newY = player.y;

      if(keys['w']) newY -= player.speed;
      if(keys['s']) newY += player.speed;
      if(keys['a']) newX -= player.speed;
      if(keys['d']) newX += player.speed;
      
      if (canMoveTo(newX, newY)) {
        player.x = newX;
        player.y = newY;
      }
      
      player.x = Math.max(0, Math.min(canvas.width - player.size, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.size, player.y));
    }

    function loop(){
      movePlayer();
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function initializeGame() {
        nextMap().then(() => { 
            initWave();
            loop();
        }).catch((error) => {
            console.error("Fallo crítico al iniciar el juego. No se pudo cargar el mapa:", error);
            mapInfo.textContent = "Mapa: Error de Carga Inicial Crítico";
        });
    }

    initializeGame();
  </script>
</body>
</html>